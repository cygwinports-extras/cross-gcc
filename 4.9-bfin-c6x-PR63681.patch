r210683 in trunk (5.0)

--- origsrc/gcc-4.9.2/gcc/cfgrtl.c	2014-01-02 16:23:26.000000000 -0600
+++ src/gcc-4.9.2/gcc/cfgrtl.c	2014-12-30 14:03:43.173502400 -0600
@@ -4223,14 +4223,14 @@ cfg_layout_initialize (unsigned int flag
   rtx x;
   basic_block bb;
 
-  /* Once bb reordering is complete, cfg layout mode should not be re-entered.
-     Entering cfg layout mode will perform optimizations on the cfg that
-     could affect the bb layout negatively or even require fixups. An
-     example of the latter is if edge forwarding performed when optimizing
-     the cfg layout required moving a block from the hot to the cold section
-     under -freorder-blocks-and-partition. This would create an illegal
-     partitioning unless some manual fixup was performed.  */
-  gcc_assert (!crtl->bb_reorder_complete);
+  /* Once bb partitioning is complete, cfg layout mode should not be
+     re-entered.  Entering cfg layout mode may require fixups.  As an
+     example, if edge forwarding performed when optimizing the cfg
+     layout required moving a block from the hot to the cold
+     section. This would create an illegal partitioning unless some
+     manual fixup was performed.  */
+  gcc_assert (!(crtl->bb_reorder_complete
+		&& flag_reorder_blocks_and_partition));
 
   initialize_original_copy_tables ();
 
--- origsrc/gcc-4.9.2/gcc/hw-doloop.c	2014-01-07 23:51:49.000000000 -0600
+++ src/gcc-4.9.2/gcc/hw-doloop.c	2014-12-30 14:04:26.711531000 -0600
@@ -636,7 +636,9 @@ reorg_loops (bool do_reorder, struct hw_
 
   loops = discover_loops (&loop_stack, hooks);
 
-  if (do_reorder)
+  /* We can't enter cfglayout mode anymore if basic block partitioning
+     already happened.  */
+  if (do_reorder && !flag_reorder_blocks_and_partition)
     {
       reorder_loops (loops);
       free_loops (loops);
--- origsrc/gcc-4.9.2/libcilkrts/configure.tgt	2013-10-29 13:37:47.000000000 -0500
+++ src/gcc-4.9.2/libcilkrts/configure.tgt	2014-12-30 17:44:59.162338800 -0600
@@ -54,6 +54,8 @@ if test x$enable_libcilkrts = x ; then
         ;;
     *-*-darwin* | *-*-aix*)
         ;;
+    *-*-cygwin*)
+        ;;
     *)
         UNSUPPORTED=1
         ;;
--- origsrc/gcc-4.9.2/libgcc/unwind-generic.h	2014-01-02 16:25:22.000000000 -0600
+++ src/gcc-4.9.2/libgcc/unwind-generic.h	2014-12-24 13:29:11.363925400 -0600
@@ -221,7 +221,9 @@ _Unwind_SjLj_Resume_or_Rethrow (struct _
    compatible with the standard ABI for IA-64, we inline these.  */
 
 #ifdef __ia64__
+#ifndef inhibit_libc
 #include <stdlib.h>
+#endif
 
 static inline _Unwind_Ptr
 _Unwind_GetDataRelBase (struct _Unwind_Context *_C)
